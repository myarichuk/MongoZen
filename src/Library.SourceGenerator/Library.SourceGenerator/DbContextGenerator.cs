using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

// ReSharper disable ComplexConditionExpression

namespace Library.SourceGenerator;

/// <summary>
/// Generates a unit‑of‑work façade ― <c>{DbContextName}Session</c> ― for every
/// concrete class that derives from <see cref="Library.DbContext" />.
/// The session exposes one <c>IMutableDbSet&lt;T&gt;</c> per <c>IDbSet&lt;T&gt;</c>
/// property found on the underlying context and a <c>SaveChangesAsync()</c>
/// method that calls <c>CommitAsync()</c> on each of those mutable sets.
/// </summary>
[Generator]
public sealed class DbContextGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var dbContextSymbols = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (node, _) => node is ClassDeclarationSyntax { BaseList: not null },
                static (ctx, ct) =>
                {
                    var cds = (ClassDeclarationSyntax)ctx.Node;
                    if (ctx.SemanticModel.GetDeclaredSymbol(cds, ct) is not INamedTypeSymbol symbol)
                    {
                        return null;
                    }

                    var compilation = ctx.SemanticModel.Compilation;
                    return !InheritsFrom(symbol, "Library.DbContext", compilation) ? null :
                        symbol.IsAbstract ? null : symbol;
                })
            .Where(static symbol => symbol is not null)!
            .Select(static (symbol, _) => symbol!);

        context.RegisterSourceOutput(dbContextSymbols, static (spc, ctxSymbol) =>
        {
            spc.AddSource(
                $"{ctxSymbol.Name}Session.g.cs",
                SourceText.From(GenerateSessionClass(ctxSymbol), Encoding.UTF8));
        });
    }

    private static bool InheritsFrom(INamedTypeSymbol type, string fullMetadataName, Compilation compilation)
    {
        var baseType = compilation.GetTypeByMetadataName(fullMetadataName);
        if (baseType == null)
        {
            return false;
        }

        for (var current = type.BaseType; current != null; current = current.BaseType)
        {
            // note: makes better sense use symbol comparer than string comparer
            if (SymbolEqualityComparer.Default.Equals(current, baseType))
            {
                return true;
            }
        }

        return false;
    }

    private static string GenerateSessionClass(INamedTypeSymbol ctxSymbol)
    {
        var ns = ctxSymbol.ContainingNamespace.IsGlobalNamespace
            ? null
            : ctxSymbol.ContainingNamespace.ToDisplayString();

        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        if (ns is not null)
        {
            sb.Append("namespace ").AppendLine(ns).AppendLine("{");
        }

        var indent = ns is null ? string.Empty : "    ";
        sb.Append(indent).Append("public sealed class ").Append(ctxSymbol.Name).Append("Session");
        sb.Append(" : global::Library.DbContextSession<").Append(ctxSymbol.ToDisplayString()).AppendLine(">");
        sb.Append(indent).AppendLine("{");

        indent += "    ";

        sb.Append(indent).Append("private readonly ").Append(ctxSymbol.ToDisplayString()).AppendLine(" _dbContext;");
        sb.AppendLine();

        // Constructor
        sb.Append(indent).Append("public ").Append(ctxSymbol.Name).Append("Session(")
          .Append(ctxSymbol.ToDisplayString()).AppendLine(" dbContext) : base(dbContext)");
        sb.Append(indent).AppendLine("{");
        sb.Append(indent).AppendLine("    _dbContext = dbContext;");

        var mutablePropNames = new List<string>();

        foreach (var member in ctxSymbol.GetMembers().OfType<IPropertySymbol>())
        {
            if (!member.Type.AllInterfaces.Any(i => i.ToDisplayString().StartsWith("Library.IDbSet")))
            {
                continue;
            }

            var entityType = ((INamedTypeSymbol)member.Type).TypeArguments[0];
            var propName = member.Name; // DbSet property names
            var sessPropName = propName;

            // generate field initialiser later
            sb.Append(indent).Append("    ").Append(sessPropName)
              .Append(" = new global::Library.MutableDbSet<")
              .Append(entityType.ToDisplayString()).Append(">(")
              .Append("_dbContext.").Append(propName).Append(", ")
              .Append("_dbContext.Options.Conventions")
              .AppendLine(");");

            mutablePropNames.Add(sessPropName);
        }

        sb.Append(indent).AppendLine("}");

        // IMutableDbSet<T> properties
        foreach (var member in ctxSymbol.GetMembers().OfType<IPropertySymbol>())
        {
            if (!member.Type.AllInterfaces.Any(i => i.ToDisplayString().StartsWith("Library.IDbSet")))
            {
                continue;
            }

            var entityType = ((INamedTypeSymbol)member.Type).TypeArguments[0];
            var propName = member.Name; // Blogs, Posts
            sb.AppendLine();
            sb.Append(indent).Append("public global::Library.IMutableDbSet<")
              .Append(entityType.ToDisplayString()).Append("> ")
              .Append(propName).AppendLine(" { get; }");
        }

        // SaveChangesAsync
        sb.AppendLine();
        sb.Append(indent).AppendLine("public async global::System.Threading.Tasks.Task SaveChangesAsync()");
        sb.Append(indent).AppendLine("{");
        foreach (var m in mutablePropNames)
        {
            sb.Append(indent).Append("    await ").Append(m).AppendLine(".CommitAsync();");
        }

        sb.Append(indent).AppendLine("}");

        indent = indent.Substring(4);
        sb.Append(indent).AppendLine("}");
        if (ns is not null)
        {
            sb.AppendLine("}");
        }

        return sb.ToString();
    }
}