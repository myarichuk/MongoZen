using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

// ReSharper disable ComplexConditionExpression

namespace MongoZen.SourceGenerator;

/// <summary>
/// Generates a unit‑of‑work façade ― <c>{DbContextName}Session</c> ― for every
/// concrete class that derives from MongoZen.DbContext.
/// The session exposes one <c>IMutableDbSet&lt;T&gt;</c> per <c>IDbSet&lt;T&gt;</c>
/// property found on the underlying context and a <c>SaveChangesAsync()</c>
/// method that calls <c>CommitAsync()</c> on each of those mutable sets.
/// </summary>
[Generator]
public sealed class DbContextSessionsGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var dbContextSymbols = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (node, _) => node is ClassDeclarationSyntax { BaseList: not null },
                static (ctx, ct) =>
                {
                    var cds = (ClassDeclarationSyntax)ctx.Node;
                    if (ctx.SemanticModel.GetDeclaredSymbol(cds, ct) is not INamedTypeSymbol symbol)
                    {
                        return null;
                    }

                    var compilation = ctx.SemanticModel.Compilation;
                    return !Utils.InheritsFrom(symbol, "MongoZen.DbContext", compilation) ? null :
                        symbol.IsAbstract ? null : symbol;
                })
            .Where(static symbol => symbol is not null)!
            .Select(static (symbol, _) => symbol!);

        context.RegisterSourceOutput(dbContextSymbols, static (spc, ctxSymbol) =>
        {
            spc.AddSource(
                $"{ctxSymbol.Name}Session.g.cs",
                SourceText.From(GenerateSessionClass(ctxSymbol), Encoding.UTF8));
        });
    }

    private static string GenerateSessionClass(INamedTypeSymbol ctxSymbol)
    {
        var ns = ctxSymbol.ContainingNamespace.IsGlobalNamespace
            ? null
            : ctxSymbol.ContainingNamespace.ToDisplayString();

        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using MongoZen;");
        sb.AppendLine();

        if (ns is not null)
        {
            sb.Append("namespace ").AppendLine(ns).AppendLine("{");
        }

        var indent = ns is null ? string.Empty : "    ";
        var indent2 = indent + "    ";
        sb.Append(indent).Append("public sealed class ").Append(ctxSymbol.Name).Append("Session");
        sb.Append(" : MongoZen.DbContextSession<").Append(ctxSymbol.ToDisplayString()).AppendLine(">");
        sb.Append(indent).AppendLine("{");



        // Constructor
        sb.Append(indent2).Append("public ").Append(ctxSymbol.Name).Append("Session(")
          .Append(ctxSymbol.ToDisplayString()).AppendLine(" dbContext) : base(dbContext)");
        sb.Append(indent2).AppendLine("{");

        var mutablePropNames = new List<string>();

        foreach (var member in ctxSymbol.GetMembers().OfType<IPropertySymbol>())
        {
            if (member.Type is not INamedTypeSymbol named ||
                named.Name != "IDbSet" ||
                named.Arity != 1 ||
                named.ContainingNamespace.ToDisplayString() != "MongoZen")
            {
                continue;
            }

            var entityType = ((INamedTypeSymbol)member.Type).TypeArguments[0];
            var propName = member.Name; // DbSet property names
            var sessPropName = propName;

            // generate field initialiser later
            sb.Append(indent2).Append("    ").Append(sessPropName)
              .Append(" = new MongoZen.MutableDbSet<")
              .Append(entityType.ToDisplayString()).Append(">(")
              .Append("_dbContext.").Append(propName).Append(", ")
              .Append("_dbContext.Options.Conventions")
              .AppendLine(");");

            mutablePropNames.Add(sessPropName);
        }

        sb.Append(indent2).AppendLine("}");
        sb.AppendLine();
        foreach (var member in ctxSymbol.GetMembers().OfType<IPropertySymbol>())
        {
            if (member.Type is not INamedTypeSymbol named ||
                named.Name != "IDbSet" ||
                named.Arity != 1 ||
                named.ContainingNamespace.ToDisplayString() != "MongoZen")
            {
                continue;
            }

            var entityType = ((INamedTypeSymbol)member.Type).TypeArguments[0];
            var propName = member.Name;

            sb.Append(indent2).Append("public MongoZen.IMutableDbSet<")
              .Append(entityType.ToDisplayString()).Append("> ")
              .Append(propName).AppendLine(" { get; }");
        }

        // SaveChangesAsync
        sb.AppendLine();
        sb.Append(indent2).AppendLine("public async ValueTask SaveChangesAsync()");
        sb.Append(indent2).AppendLine("{");
        foreach (var m in mutablePropNames)
        {
            sb.Append(indent2).Append("    await ").Append(m).AppendLine(".CommitAsync();");
        }

        sb.Append(indent2).AppendLine("}");

        sb.Append(indent).AppendLine("}");
        if (ns is not null)
        {
            sb.AppendLine("}");
        }

        return sb.ToString();
    }
}